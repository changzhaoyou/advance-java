# MySQL面试题（基础）

标签MySQL： MySQL

---
##一、drop， delete、 truncate的区别
     - delete删除表内数据：
       语法：delete from 表名 where删除条件，表结构不变，不会释放磁盘空间，MyISAM会释放磁盘，InnoDB不会释放，保留日志。
     - truncate删除表数据：
        语法：truncate from 表名，保留表结构，立刻释放磁盘空间，不管存储引擎，不保留MySQL日志。
     - drop删除表结构和数据：
        语法：drop table 表名，删除表结构和数据，立即释放磁盘空间，不管存储引擎。
     - 执行效率
        速度：drop > truncate > delete
##二、count(*)、count(1)和count(列)比较
     - count(*)和count(1)执行的效率是完全一样的。
     - count(*)的执行效率比count(col)高，因此可以用count(*)的时候就不要去用count(col)。
     - count(col)的执行效率比count(distinct col)高，不过这个结论的意义不大，这两种方法也是看需要去用。
     - 如果是对特定的列做count的话建立这个列的非聚集索引能对count有很大的帮助。
     - 如果经常count(*)的话则可以找一个最小的col建立非聚集索引以避免全表扫描而影响整体性能。
     - 在不加WHERE限制条件的情况下，COUNT(*)与COUNT(COL)基本可以认为是等价的；
     - 但是在有WHERE限制条件的情况下，COUNT(*)会比COUNT(COL)快非常多；
     - count(0)=count(1)=count(*)
     - count(指定的有效值)--执行计划都会转化为count(*)
     - 如果指定的是列名，会判断是否有null，null不计算
##三、mysql中in和exists区别（小表驱动大表）
         - mysql中的in语句是把外表和内表作hash连接，而exists语句是对外表作loop循环，每次loop循环再对     内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的     。如果查询的两个表大小相当，那么用in和exists差别不大。如果两个表中一个较小，一个是大表，则子查询     表大的用exists，子查询表小的用in。
         - not in 和not exists如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not
         extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。
##四、一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，再把 MySQL 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15？
      一般情况下，我们创建的表的类型是 InnoDB ，如果新增一条记录（不重启 MySQL 的情况下），这条记录的 ID 是18 ；但是如果重启 MySQL 的话，这条记录的 ID 是 15 。因为 InnoDB 表只把自增主键的最大 ID 记录到内存中，所以重启数据库或者对表 OPTIMIZE 操作，都会使最大 ID 丢失。
      但是，如果我们使用表的类型是 MyISAM ，那么这条记录的 ID 就是 18 。因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里面，重启 MYSQL 后，自增主键的最大 ID 也不会丢失。
##五、分表和分区的区别
        分表就是把一张表按一定的规则分解成N个具有独立存储空间的实体表。系统读写时需要根据定义好的规则得到对应的字表明，然后操作它。
        分区就是把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的。
    区别
        分表没有限制表的数量，而分区最多只能1024个分区。
        分区表中无法使用外键约束
##六、 事务的并发问题 
        1、脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。
        2、不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
        3、幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
        小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。
##七、 死锁
    产生原因：
        两个线程（两个线程并行）
        不同方向（获取方向不一致）
         相同资源（获取相同资源）
    解决办法
        尽可能避免锁的使用
        碰撞检测（发现死锁后放弃代价比较小的一方）
        超时机制（给锁设置时间，如果超时自动放弃锁，也是代价比较少的一方）
##八、MySQL 有哪些日志
        查询日志：记录了客户端的所有语句，格式为纯文本格式，可以直接进行读取。（log 日志中记录了所有数据库的操作，对于访问频繁的系统，此日志对系统性能的影响较大，建议关闭，默认关闭）。
        慢查询日志：慢查询日志记录了包含所有执行时间超过参数long_query_time（单位：秒）所设置值的 SQL 语句的日志。（纯文本格式）
        错误日志：记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。
        二进制文件：记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，不包括数据查询语句。语句以“事件”的形式保存，它描述了数据的更改过程。（定期删除日志，默认关闭）。
##九、MySQL执行顺序
  ![image.png-191.7kB][1]


  [1]: http://static.zybuluo.com/yzz19881016/exuhfjcenvz9jh2esahrl8e3/image.png